<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Camera + Hand GLB Viewer (Final)</title>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<style>
html, body {
  margin:0; padding:0;
  width:100%; height:100%;
  overflow:hidden; background:#000;
}
#wrap { position:relative; width:100%; height:100%; }
#video {
  position:absolute; inset:0;
  width:100%; height:100%;
  object-fit:cover;
  background:#000;
  z-index:0;
}
#renderCanvas {
  position:absolute; inset:0;
  width:100%; height:100%;
  z-index:1;
  background:transparent;
  touch-action:none;
}
#hud {
  position:fixed; left:10px; right:10px; bottom:10px;
  z-index:10;
  display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
}
button {
  padding:10px 12px;
  font-size:14px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,0.3);
  background:rgba(0,0,0,0.65);
  color:#fff;
}
#dbg {
  position:fixed; left:8px; top:8px; right:8px;
  z-index:11;
  display:none;
  max-height:45vh;
  overflow:auto;
  padding:10px;
  font:12px/1.35 monospace;
  color:#0f0;
  background:rgba(0,0,0,0.7);
  border-radius:12px;
  white-space:pre-wrap;
}
</style>
</head>

<body>
<div id="wrap">
  <video id="video" autoplay muted playsinline></video>
  <canvas id="renderCanvas"></canvas>
</div>

<div id="dbg"></div>

<div id="hud">
  <div style="display:flex; gap:10px;">
    <button id="btnCamera">Camera</button>
    <button id="btnPlay">Play</button>
    <button id="btnStop">Stop</button>
  </div>
  <div style="display:flex; gap:10px;">
    <button id="btnDebug">HUD</button>
    <button id="btnCopy">Copy</button>
  </div>
</div>

<script>
/* ========= CONFIG ========= */
const GLB_NAME = "animetesthand2.glb";

/* ========= STATE ========= */
let engine, scene, camera;
let container = null;
let animGroups = [];
let visibleMeshes = [];
let videoStream = null;
let debugOn = false;
let logBuf = [];

/* ========= LOG ========= */
function log(...a){
  const line = `[${new Date().toISOString()}] ` + a.join(" ");
  logBuf.push(line);
  if (logBuf.length > 300) logBuf.shift();
  if (debugOn) document.getElementById("dbg").textContent = logBuf.join("\n");
  console.log(...a);
}

/* ========= CAMERA ========= */
async function startCamera(){
  if (videoStream) return;
  const video = document.getElementById("video");
  try {
    videoStream = await navigator.mediaDevices.getUserMedia({
      video:{ facingMode:{ ideal:"environment" } }, audio:false
    });
    video.srcObject = videoStream;
    await video.play();
    log("Camera started");
  } catch(e){
    alert("Camera failed");
    log("Camera error", e);
  }
}

/* ========= BABYLON INIT ========= */
function initBabylon(){
  if (engine) return;
  const canvas = document.getElementById("renderCanvas");
  engine = new BABYLON.Engine(canvas, true);
  scene  = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color4(0,0,0,0);

  camera = new BABYLON.ArcRotateCamera(
    "cam", Math.PI/2, Math.PI/2.2, 4,
    BABYLON.Vector3.Zero(), scene
  );
  camera.attachControl(canvas, true);

  new BABYLON.HemisphericLight("h",
    new BABYLON.Vector3(0,1,0), scene);

  engine.runRenderLoop(()=>scene.render());
  window.addEventListener("resize", ()=>engine.resize());

  log("Babylon initialized");
}

/* ========= LOAD HAND ========= */
async function loadHand(){
  initBabylon();

  if (container){
    container.removeAllFromScene();
    container.dispose();
  }

  container = await BABYLON.SceneLoader.LoadAssetContainerAsync(
    "./", GLB_NAME, scene
  );
  container.addAllToScene();

  animGroups = container.animationGroups || [];
  visibleMeshes = [];

  container.meshes.forEach(m=>{
    if (m.getTotalVertices && m.getTotalVertices()>0){
      visibleMeshes.push(m);
      if (m.material){
        m.material.backFaceCulling = false;
        m.material.alpha = 1;
      }
    } else {
      m.setEnabled(false);
    }
  });

  // === auto fit ===
  const b = BABYLON.Mesh.MergeMeshes(visibleMeshes, true, true, undefined, false, true);
  const info = b.getBoundingInfo().boundingBox;
  const size = info.maximumWorld.subtract(info.minimumWorld);
  const maxDim = Math.max(size.x,size.y,size.z);
  const s = 1.8 / maxDim;

  visibleMeshes.forEach(m=>m.scaling.set(s,s,s));
  camera.radius = 3.5;

  log(`Hand loaded visible=${visibleMeshes.length} anim=${animGroups.length}`);
}

/* ========= PLAY / STOP ========= */
async function play(){
  if (!videoStream){
    alert("Start Camera first");
    return;
  }
  await loadHand();
  animGroups.forEach(g=>g.start(true));
  log("Play");
}
function stop(){
  animGroups.forEach(g=>g.stop());
  log("Stop");
}

/* ========= UI ========= */
document.getElementById("btnCamera").onclick = startCamera;
document.getElementById("btnPlay").onclick   = play;
document.getElementById("btnStop").onclick   = stop;

document.getElementById("btnDebug").onclick = ()=>{
  debugOn = !debugOn;
  document.getElementById("dbg").style.display = debugOn?"block":"none";
};

document.getElementById("btnCopy").onclick = async ()=>{
  const t = logBuf.join("\n");
  try{
    await navigator.clipboard.writeText(t);
  }catch(e){
    const ta=document.createElement("textarea");
    ta.value=t; document.body.appendChild(ta);
    ta.select(); document.execCommand("copy");
    document.body.removeChild(ta);
  }
};

/* ========= BOOT ========= */
log("Boot ready");
</script>
</body>
</html>
